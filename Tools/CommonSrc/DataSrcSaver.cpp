////////////////////////////////////////////////////////////////////////////////////////////////
//  DataSrcSaver.cpp
//	
//  Class for saving tables data and variables as C/C++ header
//	
////////////////////////////////////////////////////////////////////////////////////////////////

//#include <stdint.h>
//#include "Base/Common/PlatformTypes.h"
#include "DataSrcSaver.h"

#define FILE_EXTENSION      ".h"

#define PROGRAMME_INFO      "File automatically generated by "

#define STATIC_KEYWORD      "static"
#define CONST_KEYWORD       "const"
#define UNSIGNED_KEYWORD    "unsigned"
#define CHAR_KEYWORD        "char"   
#define SHORT_KEYWORD       "short"
#define INT_KEYWORD         "int"
#define FLOAT_KEYWORD       "float"
#define DOUBLE_KEYWORD      "double"
#define INT64_KEYWORD       "long long"
#define LONG_DOUBLE_KEYWORD "long double"

#define MAX_LINE_LEN        96
#define MAX_BITMAPS_NUM     256
#define MAX_BITMAP_SIZEX    128
#define MAX_BITMAP_SIZEY    128

#define MAX_BUFFER_SIZE     1024


static const char HexTab[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};


////////////////////////////////////////////////////////////////////////////////////////////////
CDataSrcSaver::CDataSrcSaver(const char *path, const char *file_name, bool inline_table):
mFileStream(NULL),
m_bWriteTableOnce(inline_table)
{
    m_strFileName = std::string(file_name);
    
    OpenSrcFile(path,file_name);
}
////////////////////////////////////////////////////////////////////////////////////////////////
CDataSrcSaver::~CDataSrcSaver()
{
    CloseSrcFile();
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::IsSrcFileOpened() const
{
    return mFileStream != NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, char ch_val)
{
    return this->WriteIntValue(flags,variable_name,(int)sizeof(char),true,&ch_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, unsigned char uc_val)
{
    return this->WriteIntValue(flags,variable_name,(int)sizeof(unsigned char),false,&uc_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, short i16_val)
{
    return this->WriteIntValue(flags,variable_name,(int)sizeof(short),true,&i16_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, unsigned short ui16_val)
{
    return this->WriteIntValue(flags,variable_name,(int)sizeof(unsigned short),false,&ui16_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, int i32_val)
{
    return this->WriteIntValue(flags,variable_name,(int)sizeof(int),true,&i32_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, unsigned int ui32_val)
{
    return this->WriteIntValue(flags,variable_name,(int)sizeof(unsigned int),false,&ui32_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
// ToDo: Also able to convert to hexadecimal notation
bool CDataSrcSaver::WriteIntValue(unsigned int flags, const char *variable_name, int value_size,
                                    bool is_signed, const void *value)
{
    //String that collects all data strings
    std::string strvariable;
    //Starts integer variable form new line and skipping one line
    strvariable.append("\r\n\r\n");
    //Getting variables keywords
    std::string strkeywords = GetVariableKeywords(flags);
    strvariable.append(strkeywords);
    //Getting variable type
    std::string strvartype = GetVariableIntType(value_size);
    strvariable.append(strvartype);
    //Getting variable name
    std::string strvarname = GetVariableName(flags, variable_name);
    strvariable.append(strvarname);
    //Putting initialization value into variable
    strvariable.append(" = ");
    std::string strvalue = GetStringIntValue(value_size, is_signed, value);
    strvariable.append(strvalue);
    strvariable.append(1, ';');
    
    //Write variable data into file
    bool bresult = WriteToFile(strvariable.c_str(),strvariable.size());
    
    return bresult;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteFltValue(unsigned int flags, const char *variable_name, float flt_val)
{
    return this->WriteFltValue(flags,variable_name,4,&flt_val);
}
////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteDblValue(unsigned int flags, const char *variable_name, double dbl_val)
{ 
    return this->WriteFltValue(flags,variable_name,8,&dbl_val);
}

////////////////////////////////////////////////////////////////////////////////////////////////
// ToDo: Also able to convert to hexadecimal notation
bool CDataSrcSaver::WriteFltValue(unsigned int flags, const char *variable_name, int value_size, const void *value)
{
    //String that collects all data strings
    std::string strvariable;
    //Starts integer variable form new line and skipping one line
    strvariable.append("\r\n\r\n");
    //Getting variables keywords - remove SRC_VALUE_UNSIGNED_FLAG flag
    unsigned int fltflags = flags ^ SRC_VALUE_UNSIGNED_FLAG;
    std::string strkeywords = GetVariableKeywords(fltflags);
    strvariable.append(strkeywords);
    //Getting variable type
    std::string strvartype = GetVariableFloatType(value_size);
    strvariable.append(strvartype);
    //Getting variable name
    std::string strvarname = GetVariableName(flags, variable_name);
    strvariable.append(strvarname);
    //Putting initialization value into variable
    strvariable.append(" = ");
    std::string strvalue = GetStringFltValue(value_size, value);
    strvariable.append(strvalue);
    strvariable.append(1, ';');
    
    //Write variable data into file
    bool bresult = WriteToFile(strvariable.c_str(),strvariable.size());
    
    return bresult;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteIntTable(unsigned int flags, const char *table_name, int value_size, bool is_signed, 
                                    int elem_count, int block_size, const void *data)
{
    if(table_name == NULL) return false;
    if(elem_count < 2) return false;
    if(data == NULL) return false;
    if(block_size > 1 && (elem_count % block_size)) return false;
    
    //String that collects all data strings
    std::string strvariable;
    //Starts integer variable form new line and skipping one line
    strvariable.append("\r\n\r\n");
    //Getting variables keywords
    std::string strkeywords = GetVariableKeywords(flags);
    strvariable.append(strkeywords);
    //Getting variable type
    std::string strvartype = GetVariableIntType(value_size);
    strvariable.append(strvartype);
    //Getting variable name
    std::string strvarname = GetVariableName(flags, table_name);
    strvariable.append(strvarname);
    
    //Putting brackets and equal symbols
    strvariable.append(" []");
    if(block_size > 1) {
        std::string strblocksize = std::to_string(block_size);
        strvariable += "[" + strblocksize + "]";
    }
    strvariable.append(" = ");
    
    //Begin table
    strvariable.append("\r\n{\r\n");
    
    //Start putting values into table
    //--int maxsymbols = MAX_LINE_LEN - 4 - 4;//left border 4 spaces and right border 4 spaces
    int elemnum = 1;
    bool firstinline = true;
    std::string strline;
    const unsigned char *ucvalues = (const unsigned char*)data;
    if(block_size > 1) 
    {
        while(elemnum <= elem_count) {
            std::string strblock;
            strblock.append("{");
            
            for(int i = 0; i < block_size; i++) {
                std::string strvalue = GetStringIntValue(value_size, is_signed, ucvalues);
                strblock.append(strvalue);
                strblock.append(",");
                ucvalues += value_size;
                elemnum++;
            }
            strblock.pop_back();
            strblock.append("}");
            
            if(firstinline) {
                strline.append(4,0x20);
                firstinline = false;
                strline.append(strblock);
                strline.append(", ");
                if(strline.size() >= MAX_LINE_LEN - 4) {
                    strvariable.append(strline);
                    if(elemnum < elem_count) strvariable.append("\r\n");
                    strline.clear();
                    firstinline = true;
                    
                    continue;
                }
            }
            
            if(strline.size() + strblock.size() > MAX_LINE_LEN - 4) {
                strvariable.append(strline);
                strvariable.append("\r\n");
                strvariable.append(4,0x20);
                strline.clear();
            }
            
            strline.append(strblock);
            strline.append(", ");
        }
        
        strvariable.pop_back();
        strvariable.pop_back();
    }
    else 
    {
        while(elemnum <= elem_count) {
            std::string strvalue = GetStringIntValue(value_size, is_signed, ucvalues);
            if(firstinline) { 
                strline.append(4,0x20); 
                firstinline = false;
                strline.append(strvalue);
                strline.append(", ");
                if(strline.size() >= MAX_LINE_LEN - 4) {
                    strvariable.append(strline);
                    if(elemnum < elem_count) strvariable.append("\r\n");
                    strline.clear();
                    firstinline = true;
                    
                    ucvalues += value_size;
                    elemnum++;
                    continue;
                }
            }
            
            if(strline.size() + strvalue.size() > MAX_LINE_LEN - 4) {
                strvariable.append(strline);
                strvariable.append("\r\n");
                strline.clear();
                firstinline = true;
                continue;
            }
            
            strline.append(strvalue);
            strline.append(", ");
            
            ucvalues += value_size;
            elemnum++;
        }
        
        strvariable.pop_back();
        strvariable.pop_back();

    }
    
    
    //End table
    strvariable.append("\r\n};");
    
    return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteFltTable(unsigned int flags, const char *table_name, int val_size, int elem_count, 
                                    int block_size, const void *data)
{
    return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//ToDo: split into multiple lines
bool CDataSrcSaver::WriteFileHeader(const char *description, const char *programme_info)
{
    std::string strcommentline(MAX_LINE_LEN,'/');
    std::string strheader = strcommentline;
    strheader += "//  ";
    strheader += m_strFileName;
    strheader += FILE_EXTENSION;
    strheader += "\r\n//\r\n";
    
    //Write description in header file
    if(description != NULL) {
        
        strheader += "//  ";
        std::string strdesc(description);
        strheader += strdesc;
        strheader += "\r\n//\r\n";
    }
    
    //Write programme info
    if(programme_info != NULL) {
        strheader += "//  ";
        std::string strproginfo(PROGRAMME_INFO);
        strproginfo += programme_info;
        strheader += strproginfo;
        strheader += "\r\n//\r\n";
    }
    
    strheader += strcommentline;
    
    //Write header info 
    bool bresult = WriteToFile(strheader.c_str(),strheader.size());
    
    return bresult;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteBitmapData(unsigned int flags, const char *table_name, int *sizes, unsigned int count, 
                    const char *descriptions, const unsigned char *data)
{
    return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////         
bool CDataSrcSaver::WriteInitializerList(const char *class_name, const char *object_name)
{
    return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods
////////////////////////////////////////////////////////////////////////////////////////////////
// Opening source header file for writing source code
bool CDataSrcSaver::OpenSrcFile(const char *path, const char *file_name)
{
    std::string strpath = (path==NULL) ? ("") : (path);
    
    if(!strpath.empty()) 
    {
        if(strpath.back() != char('/') || strpath.back() != char('\\'))
            strpath.push_back('/');
    }
    
    std::string strfilename = strpath + file_name;
    strfilename += FILE_EXTENSION;
    
    mFileStream = fopen(strfilename.c_str(),"wb");
    if(mFileStream == NULL)
        return false;
    
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::CloseSrcFile()
{
    if(mFileStream == NULL) return false;
    
    fclose(mFileStream);
    mFileStream = NULL;
    
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////
bool CDataSrcSaver::WriteToFile(const char *data, size_t size)
{
    size_t writtensize = fwrite(data, size, 1, mFileStream);
    return writtensize == size;
}

////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetVariableKeywords(unsigned int flags)
{
    std::string strkeywords;
    if(flags & SRC_VALUE_STATIC_FLAG) {
        strkeywords.append(STATIC_KEYWORD);
        strkeywords.append(1, 0x20); //space character
    }
    if(flags & SRC_VALUE_CONST_FLAG) {
        strkeywords.append(CONST_KEYWORD);
        strkeywords.append(1, 0x20); //space character
    }
    if(flags & SRC_VALUE_UNSIGNED_FLAG) {
        strkeywords.append(UNSIGNED_KEYWORD);
        strkeywords.append(1, 0x20); //space character
    }
    
    return strkeywords;
}

////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetVariableIntType(int value_size)
{
    std::string strvartype;
    if(value_size == 1) {
        strvartype.append(CHAR_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
    else if(value_size == 2) {
        strvartype.append(SHORT_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
    else if(value_size == 4) {
        strvartype.append(INT_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
    else if(value_size == 8) {
        strvartype.append(INT64_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetVariableFloatType(int value_size)
{
    std::string strvartype;
    if(value_size == 4) {
        strvartype.append(FLOAT_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
    else if(value_size == 8) {
        strvartype.append(DOUBLE_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
    else if(value_size > 8) {
        strvartype.append(LONG_DOUBLE_KEYWORD);
        strvartype.append(1, 0x20); //space character
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetVariableName(unsigned int flags, const char *variable_name)
{
    std::string strvarname;
    if(flags & SRC_VALUE_FILENAME_FLAG) {
        strvarname.append(m_strFileName);
        strvarname.append(1, '_');
    }
    strvarname.append(variable_name);
    
    return strvarname;
}

////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetStringIntValue(int value_size, bool is_signed, const void *value)
{
    std::string strvalue;
  
    if(value_size == 1) {
        if(is_signed) strvalue = std::to_string( int(*(char*)value) );
        else strvalue = std::to_string( unsigned(*(unsigned char*)value) );
    }
    else if(value_size == 2) {
        if(is_signed) strvalue = std::to_string( int(*(short*)value) );
        else strvalue = std::to_string( unsigned(*(unsigned short*)value) );
    }
    else if(value_size == 4) {
        if(is_signed) strvalue = std::to_string( *(int*)value );
        else strvalue = std::to_string( *(unsigned int*)value );
    }
    else if(value_size == 8) {
        if(is_signed) strvalue = std::to_string( *(long long*)value );
        else strvalue = std::to_string( *(unsigned long long*)value );
    }
    
    return strvalue;
}

////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetStringFltValue(int value_size, const void *value)
{
    std::string strvalue;
    if(value_size == 4) {
        const float &fvalue = *(const float*)value;
        strvalue = std::to_string(fvalue);
    }
    else if(value_size == 8) {
        const double &dvalue = *(const double*)value;
        strvalue = std::to_string(dvalue);
    }
    
    return strvalue;
}
////////////////////////////////////////////////////////////////////////////////////////////////
std::string CDataSrcSaver::GetStringValueHex(int value_size, const void *value)
{
    std::string strvalue;
    strvalue.append("0x");
    
    const unsigned char *ucvaluetab = (const unsigned char*)value;
    for(int i = value_size-1; i >= 0; i--) 
    {
        unsigned char uchsymbol = ucvaluetab[i];
        unsigned char valueidx2 = (uchsymbol >> 4) & 0x1111b;
        unsigned char valueidx1 = (uchsymbol) & 0x1111b;
        
        char leftsymbol = HexTab[valueidx2];
        char rightsymbol = HexTab[valueidx1];
        strvalue.append(1, leftsymbol);
        strvalue.append(1, rightsymbol);
    }
    
    return strvalue;
}
////////////////////////////////////////////////////////////////////////////////////////////////